//В программе используется вывод на консоль, поэтому подключаем функции стандартно библиотеки ввода-вывода
#include<stdio.h>
//Директива препроцесора define заменит все вхождения LENGTH и INCREMENT_VALUE в программе на 5 и 3 соответственно
#define LENGTH 5
#define INCREMENT_VALUE 3

//Функция max принимает 2 параметра и возвращает наибольшее из двух
int max(int a, int b)
{
	if(a > b)
		return a;
	else
		return b;

	//Можна написать всю функцию так. Так короче
	//return a > b ? a : b;
}

//Функция принимает указатель на первый элемент массива, длину массива и число на которое надо увеличить каждый элемент массива
//Ничего не возвращает
void increment_array(int *arr, int length, int k)
{
	//Объявляем переменную, с помощью которой мы будем контролировать что мы ещё находимся в массиве
	int i;
	for(i = 0; i < length; i++)
	{
		//Можно так. (arr + i) - здесь мы прибавляем к указателю сначала 0, потом 1, потом 2.
		//Результат выражения в скобках - указатель на нулевой, первый, второй ... i-ый элементы массива. Вспоминаем адресную арифметику.
		//К полученному адресу мы применяем операцию разыменования, то есть прохода по адресу элемента до самого элемента
		//Затем элементу присваиваем новое значение, которое равно старому, но увеличенному на k
		//*(arr+i) += k;

		//А можно так. Когда мы попадаем в функцию, arr указывает на первый элемент массива
		//К этому указателю мы применяем операцию постинкремента. это значит что arr++ сначала нам вернёт текущее значение arr а после того как мы сделаем с ним что захотим - увеличит.
		//На нулевой итерации мы получим указатель на нулевой элемент, затем применим у нему операцию разыменования, то есть *, и получим значение нулевого элемента и увеличим его на k
		//Мы сделали всё что хотели и теперь сработает постинкремент и arr станет указывать на первый элемент массива. Делаем всё вышеперечисленное для первого элемента массива, для второго и т д.
		//При этом i казждый раз увеличивается и мы контролируем с его помощью что мы не вышли за пределы массива, так как мы заранее знаем его длину length.
		*(arr++) += k; 

	}
}

//Функция печать массива, за комментариями идём в функцию increment_array
void print_array(int* arr, int length)
{
	int i;
	for(i = 0; i < length; i++)
		printf("%d ", *(arr + i));
	printf("\n");
}

//Функция обмена двух целых числел значениями
//Принимает указатели на числа, то есть их адреса
//Обратите внимание что если предавать не адреса, а сами числа, то мы изменим ЛОКАЛЬНЫЕ КОПИИ, а те переменные, которые мы передавали бы в функцию, не изменились бы
void swap(int *a, int *b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

int main()
{
	int arr[LENGTH] = {1, 2, 3, 4, 5};
	int a = 10, b = 15, m;

	printf("Max\n");
	m = max(a,b);
	printf("a = %d, b = %d Max(a,b) = %d\n", a, b, m);
	
	printf("\nArray incrementing on %d\n", INCREMENT_VALUE);
	printf("Before: ");
	print_array(arr, LENGTH);
	increment_array(arr, LENGTH, INCREMENT_VALUE);
	printf("After: ");
	print_array(arr, LENGTH);

	printf("\nSwap\n");
	printf("Before: a = %d, b = %d\n", a, b);
	//Мы передаём АДРЕСА переменных, а не из значения
	swap(&a, &b);
	printf("After: a = %d, b = %d\n", a, b);
}
