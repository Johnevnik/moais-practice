#include <stdio.h>
//Подключаем библиотеку работы со строками для сравнения результатов работы наших функций со стандартными
#include <string.h>
//Подключаем библиотеку математических функций чтобы использовать функцию возведения в степень.
#include <math.h>

//Функция подсчёт длины строки. Принимает указатель на первый элемент массива-строки. 
//Обратите внимание что нам не нужен второй параметр длины массива, так как длина строки ограничивается не массивом в котором она лежит, а количеством символов до символа '\0'
int get_string_length(char* s)
{
	//Объявляем переменную, которая будет служить счётчиком длины строки
	int counter = 0;
	//Последовательность действий в условии цикла while следующая:
	//0. s УКАЗЫВАЕТ на нулевой элемент массива, в котором лежит строка, так как массив содержит элементы типа char то этот нулевой элемент - "первый" символ строки
	//1. К указателю s мы применяем операцию постинкремента, это значит что s++ сначала нам вернёт текущее значение s а после того как мы сделаем с ним что захотим - увеличит.
	// На нулевой итерации мы получим указатель на нулевой элемент 
	//2. затем применим к полученному указателю операцию разыменования, то есть *, и получим значение нулевого элемента, сравним его с '\0'
	// После сравнения сработает постинкремент и s станет указывать на первый элемент массива. Делаем всё вышеперечисленное для первого элемента массива, для второго и т д.
	//3. Если очередной элемент не равен '\0', то мы увеличим счётчик на 1 и переидём к следующей итерации цикла 
	//4. Как только очередным символом окажется '\0' мы выйдем из цикла while
	while(*s++ != '\0')
	{
		counter++;
	}
	//Возвращаем подсчитанные символы
	return counter;
}

//Функция меняет регистр (заглавные буквы на строчные) для строки, указатель на которую передан ей в качестве первого параметра
void registry(char* str)
{
	int p, i = 0;
	//Подсчитываем разницу между КОДАМИ символов 'A' и 'a' в таблице ASCII (посмотрите что это)
	p='A'-'a';
	//С помощью цикла двигаемся до конца строки
	while (*str != '\0') 
	{
		//Если код очередного символа находится между кодами символов 'A' и 'Z', то есть буква заглавная ...
		if (*str>='A' && *str<='Z')
		{
			//... то мы приводим её к строчному виду. Изучив таблицу разберитесь почему именно так
			*str -= p;
		}
		//Сдвигаем указатель на следующий символ
		++str;
	}
	//Обратите внимание - функция ничего не возвращает, так как ей передан адрес строки, которую необходимо изменить, 
	//то есть если мы меняем строку здесь, она меняется и там, откуда была вызвана функция
}

//void test_registry(char* original)
//{
//	printf("Original: %s, ", original);
//	registry(original);
//	printf("Your result: %s\n", original);
//}

 
//Функция сравнивает две строки. Договариваемся что функция возвращает 0 если строки не равны и 1 если равны
int compare(char* str1, char* str2)
{ 
	//str1 и str2 в начале функции указывают на нулевые элементы соответствующих строк
	//С помощью цикла передвигаемся по обеим строкам одновременно, пока не встретим символ конца строки хотя бы в одной строке
	while (*str1 != '\0' && *str2 != '\0')
	{ 
		//Когда очередные символы, стоящие на одинаковых позициях в строках оказутся разными выхдим из функции возвращая 0
		if(*str1 != *str2)
			return 0;
		//Если символы совпали, то мы сдвигаем указатели в обеих строках на следующиие символы
		str1++;
		str2++;
	}
	//Когда одна из строк закончилась нужно проверить закончилась ли также вторая
	//Для этого мы сравниваем символы, стоящие на позиция, на которуе указывают str1 и str2
	if(*str1 == *str2)
	{
		//если символы равны, то обе строки закончились и они равны
		return 1;
	}
	else
	{
		//Если не равны, то одна строка закончилась, а вторая нет и значит строки не равны
		return 0;
	}
	//А можно написать это так. Будет круче и короче!
	//return *str1 == *str2 ? 1 : 0;
}

//Функция принимает на первый элемент массива символов в котором лежит двоичное представление какого-либо числа (например 1001101)
//На самом деле массив может быть любой длины, но нас это не интересует. так как мы знаем что строки заканчиваются символом '\0' и для нас имеет значение только то что находится до него
int to_decimal(char* str)
{
	int i;
	//Здесь мы будем накапливать результат
	int result = 0;
	//Длина строки нам нужна для того чтобы двигаться с конца строки. а не сначала. С конча потому что младшие разряды находятся справа.
	int len = get_string_length(str);
	//Так мы организовали цикл, в котором i уменьшается после каждой итерации
	for (i = len - 1; i >= 0; i--)
	{
		//Если в очередной позиции находится символ '1', то нужно к результату добавить 2 в степени номер позиции этого символа в двоичной строке (считая справа)
		if(str[i] == '1')
		{
			result += pow((double)2, (double)(len - i - 1));
		}
	}
	//Возвращаем результат
	return result;
}

void test_decimals(char* str, int decimal)
{
	printf("%s\tExpected:%d\tActual:%d\t%s\n", 
		str, 
		decimal, 
		to_decimal(str),
		to_decimal(str) == decimal ? "OK" : "Error");
}

void main ()
{
	//Для тестирования функции вычисления длины строки
	char str[4][50] = {"string", "this is Sparta!", "hello, world", ""};
	int length, length_lib, i;

	//Для тестирования работы функции registry
	char registry_string[101];

	//Для сравнения строк
	int result1, result2, result3;
	char str1[] = "Hello";
	char str2[] = "Goodbye";
	char str3[] = "Hello!";

	printf("String lengths\n");
	for (i = 0; i < 4; i++)
	{
		length = get_string_length(str[i]);
		length_lib = strlen(str[i]);
		printf("String: %s\nYour code: %d, LibraryCode: %d ", str[i], length, length_lib);
		if (length == length_lib)
		{
			printf("Correct\n", length, length_lib);
		}
		else
		{
			printf("Error\n", length, length_lib);
		}
	}

	printf("\nComparison\n");
	result1 = compare(str1, str2);
	result2 = compare(str1, str1);
	result3 = compare(str1, str3);
	printf("%s %s %d\n", str1, str2, result1);
	printf("%s %s %d\n", str1, str1, result2);
	printf("%s %s %d\n", str1, str3, result3);

	printf("\nRegistry\n");
	printf("Enter string for test:");
	scanf("%s", registry_string);
	registry(registry_string);
	printf("Lowercase string:%s\n", registry_string);

	printf("\nDecimals\n");
	test_decimals("1010", 10);
	test_decimals("0001", 1);
	test_decimals("100001", 33);
}